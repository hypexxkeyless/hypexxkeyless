--// ===================================================
--// IMPORTANT
--// ===================================================

local function print() end
local function warn() end
-- Hypexx Keyless Menu - Sirius Rayfield UI
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

local Window = Rayfield:CreateWindow({
	Name = "Hypexx-Keyless Menu",
	LoadingTitle = "Hypexx Loader",
	LoadingSubtitle = "No Key • Free Access",
	ConfigurationSaving = {
		Enabled = true,
		FolderName = "Hypexx", -- Config klasörü
		FileName = "KeylessSettings"
	},
	KeySystem = false
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()

-- Vars
local noclipEnabled = false
local walkspeedBoost = 0
local noclipConnection

-- 📌 Home Tab
local Home = Window:CreateTab("Home", 4483345998)
Home:CreateParagraph({Title = "Welcome to Hypexx Menu", Content = "Free Roblox Enhancer by Hypexx"})

Home:CreateButton({
	Name = "Copy Discord",
	Callback = function()
		setclipboard("https://discord.gg/yourserverlink")
	end
})

Home:CreateButton({
	Name = "Copy YouTube",
	Callback = function()
		setclipboard("https://youtube.com/@yourchannel")
	end
})

-- 🧍 Player Settings Tab
local PlayerTab = Window:CreateTab("Player Settings", 4483345998)

-- Reset
PlayerTab:CreateButton({
	Name = "Reset Character",
	Callback = function()
		local hum = Player.Character and Player.Character:FindFirstChildOfClass("Humanoid")
		if hum then hum.Health = 0 end
	end
})

-- Noclip
PlayerTab:CreateToggle({
	Name = "Noclip",
	CurrentValue = false,
	Callback = function(Value)
		noclipEnabled = Value
		if noclipEnabled then
			noclipConnection = RunService.Stepped:Connect(function()
				local char = Player.Character
				if char then
					for _, part in pairs(char:GetDescendants()) do
						if part:IsA("BasePart") then
							part.CanCollide = false
						end
					end
				end
			end)
		else
			if noclipConnection then noclipConnection:Disconnect() end
		end
	end
})

-- Walkspeed Boost
PlayerTab:CreateSlider({
	Name = "Walkspeed Boost",
	Range = {0, 80},
	Increment = 1,
	Suffix = "Speed",
	CurrentValue = 0,
	Callback = function(Value)
		walkspeedBoost = Value / 30
	end
})

RunService.Heartbeat:Connect(function()
	local char = Player.Character
	if char and walkspeedBoost > 0 then
		local hum = char:FindFirstChildOfClass("Humanoid")
		local root = char:FindFirstChild("HumanoidRootPart")
		if hum and root and hum.MoveDirection.Magnitude > 0 then
			root.CFrame = root.CFrame + root.CFrame.LookVector * walkspeedBoost
		end
	end
end)

-- Anti-Death
PlayerTab:CreateToggle({
	Name = "Anti-Death (Freeze Health)",
	CurrentValue = false,
	Callback = function(Value)
		if Value then
			getfenv().antideath = Player.Character:FindFirstChildOfClass("Humanoid").HealthChanged:Connect(function()
				Player.Character:FindFirstChildOfClass("Humanoid").Health = 100
			end)
		else
			if getfenv().antideath then
				getfenv().antideath:Disconnect()
				getfenv().antideath = nil
			end
		end
	end
})

-- Anti-Fall
PlayerTab:CreateToggle({
	Name = "Anti-Fall",
	CurrentValue = false,
	Callback = function(Value)
		if Value then
			getfenv().nofall = RunService.RenderStepped:Connect(function()
				local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
				if root and root.Velocity.Y < -50 then
					root.Velocity = Vector3.zero
				end
			end)
		else
			if getfenv().nofall then
				getfenv().nofall:Disconnect()
				getfenv().nofall = nil
			end
		end
	end
})

-- Max Zoom
PlayerTab:CreateSlider({
	Name = "Camera Max Zoom",
	Range = {20, 1000},
	Increment = 10,
	Suffix = "Zoom",
	CurrentValue = 20,
	Callback = function(Value)
		Player.CameraMaxZoomDistance = Value
	end
})

-- Infinite Stamina (experimental)
PlayerTab:CreateButton({
	Name = "Infinite Stamina",
	Callback = function()
		for _, f in pairs(getgc(true)) do
			if typeof(f) == "function" and debug.getinfo(f).name == "setStamina" then
				hookfunction(f, function(self, stamina)
					return self, math.huge
				end)
				break
			end
		end
	end
})
--// ===================================================
--// REMOTE EVENT DECLARATIONS
--// ===================================================

--// Used in: Player Settings (Tab1), Auto Shoot (SilentAimTab), Aimbot (Tab6), Crim-Cop Mod's (playerStuffTab)
local wantedRemoteEvent = game:GetService("ReplicatedStorage")["ZDD"]["a3581179-8ba7-43e9-930f-ce588a96c919"]

--// Used in: Crim-Cop Mod's (playerStuffTab)
local radarRemoteEvent = game:GetService("ReplicatedStorage")["ZDD"]["33b83d12-cf41-43c5-9370-45721b8b0e80"]

--// Used in: Crim-Cop Mod's (playerStuffTab)
local EquipRemoteEvent = game:GetService("ReplicatedStorage")["ZDD"]["03b49302-a5f2-4604-918e-098bfbdeb34f"]

--// Used in: Crim-Cop Mod's (playerStuffTab)
local ArrestRemoteEvent = game:GetService("ReplicatedStorage")["ZDD"]["06a54218-5ca6-4f03-88b7-a7157db417f4"]

--// Used in: Auto Shoot (SilentAimTab) - Gun shooting remote
local ShootRemoteEvent = game:GetService("ReplicatedStorage")["ZDD"]["0b6c4b19-e763-4590-b964-bbfc01b63348"]

--// Used in: Crim-Cop Mod's (playerStuffTab) - Taser shooting remote
local TaserShootRemote = game:GetService("ReplicatedStorage")["ZDD"]["8b8ec986-2836-42ad-8e52-41d7fe03c958"]

 -- ===================================================
-- UI INITIALIZATION
-- ===================================================

local Window = OrionLib:MakeWindow({Name = "HypexxHub │ Keyless Menu ", HidePremium = false, SaveConfig = true, ConfigFolder = "OrionTest"})

local Tab = Window:MakeTab({
    Name = "│Home",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

Tab:AddParagraph("© 2025 Hypexx Scripting", "")
Tab:AddParagraph("Discord-->https://discord.gg/HuQCQcPTKK", "")

Tab:AddButton({
    Name = "Copying Discord Link",
    Callback = function()
        setclipboard("hypexxkeyless")
        OrionLib:MakeNotification({
	Name = "script name",
	Content = "Link Copied",
	Image = "rbxassetid://4483345998",
	Time = 5
})

    end    
})

Tab:AddParagraph("YouTube-->hypexx", "")

Tab:AddButton({
    Name = "Copying YouTube Link",
    Callback = function()
        setclipboard("hypexx")
        OrionLib:MakeNotification({
	Name = "YouTube",
	Content = "Link Copied",
	Image = "rbxassetid://4483345998",
	Time = 5
})

    end    
})

local Tab1 = Window:MakeTab({
	Name = "│Player Settings",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

Tab1:AddButton({
	Name = "Reset Character",
	Callback = function()
		local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.Health = 0
		end
	end    
})

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local noclipEnabled = false
local noclipConnection

local function SetNoclipMode(enable)
	for _, part in pairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = not enable
		end
	end
end

Tab1:AddToggle({
	Name = "Noclip",
	Default = false,
	Callback = function(Value)
		noclipEnabled = Value
		if Value then
			SetNoclipMode(true)
			if not noclipConnection then
				noclipConnection = RunService.Stepped:Connect(function()
					if noclipEnabled then
						SetNoclipMode(true)
					end
				end)
			end
		else
			SetNoclipMode(false)
			if noclipConnection then
				noclipConnection:Disconnect()
				noclipConnection = nil
			end
		end
	end    
})

player.CharacterAdded:Connect(function(newChar)
	character = newChar
	if noclipEnabled then
		SetNoclipMode(true)
	end
end)

Tab1:AddToggle({
	Name = "Anti-Death (makes you stand up)",
	Default = false,
	Callback = function(Value)
		local env = getfenv()
		if Value then
			env.downed = true
			env.antichanged1 = game.Players.LocalPlayer.Character.Humanoid:GetPropertyChangedSignal("Health"):Connect(function()
				game.Players.LocalPlayer.Character.Humanoid.Health = 100
			end)
		else
			if env.antichanged1 then
				env.antichanged1:Disconnect()
				env.antichanged1 = nil
			end
			env.downed = false
		end
	end
})

local boostAmount = 5

Tab1:AddSlider({
	Name = "WalkSpeed",
	Min = 0,
	Max = 82,
	Default = 0,
	Color = Color3.fromRGB(255,255,255),
	Increment = 1,
	ValueName = "Speed",
	Callback = function(Value)
		boostAmount = Value / 335
	end    
})

RunService.Heartbeat:Connect(function()
	local char = player.Character
	if not char then return end

	local humanoid = char:FindFirstChildOfClass("Humanoid")
	local hrp = char:FindFirstChild("HumanoidRootPart")

	if humanoid and hrp and boostAmount > 0 and humanoid.MoveDirection.Magnitude > 0 then
		hrp.CFrame = hrp.CFrame + hrp.CFrame.LookVector * boostAmount
	end
end)

----------------------------------------------------------------------

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local noclipEnabled = false
local noclipConnection = nil
local function SetNoclipMode(enable)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = not enable
        end
    end
end

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    if noclipEnabled then
        SetNoclipMode(true)
    end
end)

Tab1:AddBind({
    Name = "Noclip Keybind Mod",
    Default = Enum.KeyCode.X,
    Hold = false,
    Callback = function()
        noclipEnabled = not noclipEnabled
        if noclipEnabled then
            SetNoclipMode(true)
            if not noclipConnection then
                noclipConnection = RunService.Stepped:Connect(function()
                    if noclipEnabled then
                        SetNoclipMode(true)
                    end
                end)
            end
        else
            SetNoclipMode(false)
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end    
})

Tab1:AddToggle({
    Name = "Anti-Fall//Damage",
    Default = false,
    Callback = function(Value)
        if Value then
            getfenv().ANTIFALL = true
            getfenv().nofall = game:GetService("RunService").RenderStepped:Connect(function()
                local character = game.Players.LocalPlayer.Character
                if character then
                    local rootPart = character:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        local raycastParams = RaycastParams.new()
                        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                        raycastParams.FilterDescendantsInstances = {character}

                        local ray = workspace:Raycast(rootPart.Position, Vector3.new(0, -8, 0), raycastParams)
                        if ray and rootPart.Velocity.Y < -50 then
                            rootPart.Velocity = Vector3.new(0, 0, 0)
                        end
                    end
                end
            end)
        else
            getfenv().ANTIFALL = false
            if getfenv().nofall then
                getfenv().nofall:Disconnect()
                getfenv().nofall = nil
            end
        end
    end
})

Tab1:AddButton({
    Name = "İnfinite Stamina (works on good executors)",
    Callback = function()
        if getfenv().firsttime == nil then
            getfenv().firsttime = true

            local func
            for i, v in pairs(getgc(true)) do
                if type(v) == "function" and debug.getinfo(v).name == "setStamina" then
                    func = v
                    break
                end
            end

            if func then
                local old = hookfunction(func, function(...)
                    local args = {...}
                    return args[1], math.huge
                end)
            end
        end
    end    
})

Tab1:AddSlider({
    Name = "Camera Max Zoom",
    Min = 20,
    Max = 1500,
    Default = 20,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "Distance",
    Callback = function(Value)
        game.Players.LocalPlayer.CameraMaxZoomDistance = Value
    end    
})

local Tab2 = Window:MakeTab({
	Name = "│Vehicle Mod's",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})



-- Add infinite fuel toggle
local infiniteFuelConnection
Tab2:AddToggle({
    Name = "Infinite Fuel",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Create a new connection if one doesn't exist
            if not infiniteFuelConnection then
                infiniteFuelConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    local vehiclesFolder = workspace:FindFirstChild("Vehicles")
                    if vehiclesFolder then
                        local vehicle = vehiclesFolder:FindFirstChild(game.Players.LocalPlayer.Name)
                        if vehicle then
                            vehicle:SetAttribute("currentFuel", 9999999)
                        end
                    end
                end)
            end
        else
            -- Disconnect the existing connection if it exists
            if infiniteFuelConnection then
                infiniteFuelConnection:Disconnect()
                infiniteFuelConnection = nil
            end
        end
    end
})

function bringcar()
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        warn("Karakter veya HumanoidRootPart bulunamadı.")
        return false
    end

    local car = workspace:FindFirstChild("Vehicles") and workspace.Vehicles:FindFirstChild(player.Name)
    if not car then
        warn("Araç bulunamadı.")
        return false
    end

    local driveSeat = car:FindFirstChild("DriveSeat", true)
    if not driveSeat then
        warn("DriveSeat bulunamadı.")
        return false
    end

    car.PrimaryPart = driveSeat
    local targetPosition = character.HumanoidRootPart.Position + character.HumanoidRootPart.CFrame.LookVector * 10
    local lookAtPosition = character.HumanoidRootPart.Position

    car:SetPrimaryPartCFrame(CFrame.new(targetPosition, lookAtPosition))
    task.wait(0.5)

    driveSeat:Sit(character:FindFirstChildOfClass("Humanoid"))
    local waitTime = 0
    while character:FindFirstChildOfClass("Humanoid").SeatPart ~= driveSeat and waitTime < 5 do
        task.wait(0.1)
        waitTime = waitTime + 0.1
    end

    if character:FindFirstChildOfClass("Humanoid").SeatPart ~= driveSeat then
        warn("Karakter araca bindirilemedi.")
        return false
    end

    print("Araç başarıyla getirildi ve karakter bindirildi.")
    return true
end
Tab2:AddButton({
    Name = "Bring My Car",
    Callback = function()
        bringcar()
    end
})
---------------------------------------
Tab2:AddButton({
    Name = "Sit in Car",
    Callback = function()
        local plr = game.Players.LocalPlayer
        local vehiclesFolder = workspace:FindFirstChild("Vehicles")
        if vehiclesFolder then
            local vehicle = vehiclesFolder:FindFirstChild(plr.Name)
            if vehicle then
                local driveSeat = vehicle:FindFirstChild("DriveSeat")
                if driveSeat then
                    local char = plr.Character
                    if char then
                        local humanoid = char:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            driveSeat:Sit(humanoid)
                            task.wait(0.1)
                            OrionLib:MakeNotification({
                                Name = "Success",
                                Content = "Successfully sat in vehicle",
                                Image = "rbxassetid://4483345998",
                                Time = 2
                            })
                        else
                            OrionLib:MakeNotification({
                                Name = "Error",
                                Content = "Humanoid not found",
                                Image = "rbxassetid://4483345998",
                                Time = 2
                            })
                        end
                    else
                        OrionLib:MakeNotification({
                            Name = "Error",
                            Content = "Character not found",
                            Image = "rbxassetid://4483345998",
                            Time = 2
                        })
                    end
                else
                    OrionLib:MakeNotification({
                        Name = "Error",
                        Content = "DriveSeat not found in vehicle",
                        Image = "rbxassetid://4483345998",
                        Time = 2
                    })
                end
            else
                OrionLib:MakeNotification({
                    Name = "Error",
                    Content = "Your vehicle not found",
                    Image = "rbxassetid://4483345998",
                    Time = 2
                })
            end
        else
            OrionLib:MakeNotification({
                Name = "Error",
                Content = "Vehicles folder not found",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        end
    end
})

--------------------------------------------------------


local flightGuiEnabled = false
local flightEnabled = false
local flightSpeed = 1
local flightGui
local guiFlightDirection = Vector3.new(0, 0, 0) 
local buttonDirections = {
    W = Vector3.new(0, 0, -1),
    A = Vector3.new(-1, 0, 0),
    S = Vector3.new(0, 0, 1),
    D = Vector3.new(1, 0, 0),
}

local function createFlightGui()
    local screenGui = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
    screenGui.Name = "FlightControlGui"
    screenGui.Enabled = false

    local frame = Instance.new("Frame", screenGui)
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.Position = UDim2.new(0.5, 0, 0.8, 0)
    frame.Size = UDim2.new(0, 200, 0, 200)
    frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    frame.BackgroundTransparency = 0.2
    local drag = Instance.new("UIDragDetector", frame)

    local uiCorner = Instance.new("UICorner", frame)
    uiCorner.CornerRadius = UDim.new(0.1, 0)

    local buttonSize = UDim2.new(0, 60, 0, 60)
    local positions = {
        W = UDim2.new(0.5, -30, 0, 0),
        A = UDim2.new(0, 0, 0.5, -30),
        S = UDim2.new(0.5, -30, 1, -60),
        D = UDim2.new(1, -60, 0.5, -30),
    }
    local rotations = {
        W = 0,
        A = -90,
        S = 180,
        D = 90,
    }

    for key, direction in pairs(buttonDirections) do
        local button = Instance.new("ImageButton", frame)
        button.Name = key .. "Button"
        button.Position = positions[key]
        button.Size = buttonSize
        button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        button.BackgroundTransparency = 0.1
        button.Image = "rbxassetid://11432834725"
        button.Rotation = rotations[key]

        local buttonCorner = Instance.new("UICorner", button)
        buttonCorner.CornerRadius = UDim.new(0.1, 0)

        button.MouseButton1Down:Connect(function()
            guiFlightDirection = guiFlightDirection + direction
        end)
        button.MouseButton1Up:Connect(function()
            if direction == buttonDirections.W then
                guiFlightDirection = Vector3.new(guiFlightDirection.X, guiFlightDirection.Y, 0)
            elseif direction == buttonDirections.A then
                guiFlightDirection = Vector3.new(0, guiFlightDirection.Y, guiFlightDirection.Z)
            elseif direction == buttonDirections.S then
                guiFlightDirection = Vector3.new(guiFlightDirection.X, guiFlightDirection.Y, 0)
            elseif direction == buttonDirections.D then
                guiFlightDirection = Vector3.new(0, guiFlightDirection.Y, guiFlightDirection.Z)
            end
        end)
    end

    return screenGui
end

local function toggleFlightGui(Value)
    if not flightGui then
        flightGui = createFlightGui()
    end
    guiFlightDirection = Vector3.zero
    flightGui.Enabled = Value
    flightGuiEnabled = Value
end

-- Define UserInputService
local UserInputService = game:GetService("UserInputService")


local toggleCarFlyButton = Tab2:AddToggle({
    Name = "Car Fly Enable/Disable",
    Default = false,
    Callback = function(Value)
        flightEnabled = Value
    end
})

Tab2:AddBind({
    Name = "Car fly Keybind",
    Default = Enum.KeyCode.X,
    Hold = false,
    Callback = function()
        flightEnabled = not flightEnabled
        toggleCarFlyButton:Set(flightEnabled)
    end   
})

Tab2:AddToggle({
    Name = "Mobile Fly Menu",
    Default = false,
    Callback = function(Value)
        toggleFlightGui(Value)
    end
})

-- Render step for movement
game:GetService("RunService").RenderStepped:Connect(function() 
    local Character = game.Players.LocalPlayer.Character
    if flightEnabled then
        if Character then
            if Character:FindFirstChild("Humanoid") then
                local SeatPart = Character:FindFirstChild("Humanoid").SeatPart
                if SeatPart and SeatPart.Name == "DriveSeat" then
                    local Vehicle = SeatPart.Parent
                    if Vehicle then
                        Character.Parent = Vehicle
                        if not Vehicle.PrimaryPart then
                            Vehicle.PrimaryPart = SeatPart
                        end

                        local PrimaryPartCFrame = Vehicle:GetPrimaryPartCFrame()
                        local cameraLook = workspace.CurrentCamera.CFrame.LookVector

                        Vehicle:SetPrimaryPartCFrame(CFrame.new(PrimaryPartCFrame.Position, PrimaryPartCFrame.Position + cameraLook) *
                            CFrame.new(
                                ((UserInputService:IsKeyDown(Enum.KeyCode.D) and flightSpeed or 0) - 
                                 (UserInputService:IsKeyDown(Enum.KeyCode.A) and flightSpeed or 0)) + guiFlightDirection.X * flightSpeed,
                                ((UserInputService:IsKeyDown(Enum.KeyCode.E) and flightSpeed / 2 or 0) - 
                                 (UserInputService:IsKeyDown(Enum.KeyCode.Q) and flightSpeed / 2 or 0)) + guiFlightDirection.Y * flightSpeed,
                                ((UserInputService:IsKeyDown(Enum.KeyCode.S) and flightSpeed or 0) - 
                                 (UserInputService:IsKeyDown(Enum.KeyCode.W) and flightSpeed or 0)) + guiFlightDirection.Z * flightSpeed
                            ))
                        SeatPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        SeatPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    end
                end
            end
        end
    else
        if Character then
            Character.Parent = defaultCharacterParent or Character.Parent
            defaultCharacterParent = Character.Parent
        end
    end
end)


Tab2:AddSlider({ 
    Name = "Car Fly Speed",
    Min = 10,
    Max = 150, 
    Default = (flightSpeed * 50),
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 10,
    ValueName = "Speed", 
    Callback = function(Value)
        flightSpeed = (Value / 50)
    end    
})



------------------------------
local VehiclesFolder = workspace:WaitForChild("Vehicles")
local LocalPlayer = game:GetService("Players").LocalPlayer


_G.__SuspLen = _G.__SuspLen or {}
_G.__SuspSet = _G.__SuspSet or function(offset)
	local player = game:GetService("Players").LocalPlayer
	local vehicleFolder = workspace:FindFirstChild("Vehicles")
	local vehicle = vehicleFolder and vehicleFolder:FindFirstChild(player.Name)
	if not vehicle then return end
	for _, part in ipairs(vehicle:GetDescendants()) do
		if part:IsA("SpringConstraint") then
			if not _G.__SuspLen[part] then _G.__SuspLen[part] = part.FreeLength end
			part.FreeLength = math.max(_G.__SuspLen[part] + offset, 1)
		end
	end
end
Tab2:AddSlider({
	Name = "Suspension Hight",
	Min = -1.5,
	Max = 2.0,
	Default = 0,
	Color = Color3.fromRGB(255, 255, 255),
	Increment = 0.05,
	ValueName = "Offset",
	Callback = function(value)
		_G.__SuspSet(value)
	end
})
-- Add vehicle upgrade sliders
Tab2:AddLabel("Vehicle Upgrades")

Tab2:AddSlider({
    Name = "Car Accelerate Force",
    Min = 1,
    Max = 6,
    Default = 1,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Level",
    Callback = function(Value)
        local vehiclesFolder = workspace:FindFirstChild("Vehicles")
        if vehiclesFolder then
            local vehicle = vehiclesFolder:FindFirstChild(game.Players.LocalPlayer.Name)
            if vehicle then
                vehicle:SetAttribute("engineLevel", Value)
            end
        end
    end
})

Tab2:AddSlider({
    Name = "Extra Health",
    Min = 1,
    Max = 6,
    Default = 1,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Level",
    Callback = function(Value)
        local vehiclesFolder = workspace:FindFirstChild("Vehicles")
        if vehiclesFolder then
            local vehicle = vehiclesFolder:FindFirstChild(game.Players.LocalPlayer.Name)
            if vehicle then
                vehicle:SetAttribute("armorLevel", Value)
            end
        end
    end
})

Tab2:AddSlider({
    Name = "BrakeForce",
    Min = 1,
    Max = 6,
    Default = 1,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Level",
    Callback = function(Value)
        local vehiclesFolder = workspace:FindFirstChild("Vehicles")
        if vehiclesFolder then
            local vehicle = vehiclesFolder:FindFirstChild(game.Players.LocalPlayer.Name)
            if vehicle then
                vehicle:SetAttribute("brakesLevel", Value)
            end
        end
    end
})

-----------------------------------------------------------
local lplr = game:GetService("Players").LocalPlayer



local Tab3 = Window:MakeTab({
	Name = "│Teleport",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

_G.flightSpeed = 190 -- Default speed

-----------------------------------------------
-----------------------------------------------
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")

local minSpeed = 170
local maxSpeed = 240

-- FPS ölçümü
local fps = 60
RunService.RenderStepped:Connect(function(deltaTime)
	fps = math.floor(1 / deltaTime)
end)

-- Ping (RTT) ölçümü (ms cinsinden)
local function getPing()
	local dataPing = Stats:FindFirstChild("Network"):FindFirstChild("Ping")
	if dataPing then
		return dataPing:GetValue()
	end
	return 100 -- varsayılan ping
end

-- Uçuş hızını güncelle
task.spawn(function()
	while true do
		local currentPing = getPing()
		local pingFactor = math.clamp(1 - (currentPing / 300), 0, 1) -- yüksek ping = yavaşlat

		local fpsFactor = math.clamp(fps / 60, 0.5, 1.2) -- düşük fps = yavaşlat

		local adjustedSpeed = math.clamp(minSpeed * fpsFactor * pingFactor, minSpeed, maxSpeed)

		_G.flightSpeed = math.floor(adjustedSpeed)

		task.wait(1) -- her saniye bir kez kontrol et
	end
end)
-----------------------------------------------
-----------------------------------------------

-- Modelin 'PrimaryPart'ını ayarlama fonksiyonu
local function setPrimaryPart(vehicleModel)
	local body = vehicleModel:FindFirstChild("Body")
	if body then
		local mass = body:FindFirstChild("Mass")
		if mass then
			vehicleModel.PrimaryPart = mass
			return mass
		else
			warn("Body modelinin içinde 'Mass' parçası bulunamadı.")
		end
	else
		warn("Araç modelinde 'Body' modeli bulunamadı.")
	end
	return nil
end

-- Sabit hızla tween yapmak için fonksiyon
local function createTween(targetInstance, startCFrame, endCFrame, speed)
	local distance = (endCFrame.Position - startCFrame.Position).Magnitude
	local duration = distance / speed

	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
	local tweenValue = Instance.new("CFrameValue")
	tweenValue.Value = startCFrame

	tweenValue.Changed:Connect(function()
		if targetInstance:IsA("Model") then
			targetInstance:PivotTo(tweenValue.Value)
		else
			targetInstance.CFrame = tweenValue.Value
		end
	end)

	local tween = TweenService:Create(tweenValue, tweenInfo, {Value = endCFrame})
	tween:Play()
	return tween
end

-- frameTween(CFrame.new(...)) şeklinde kullanım
function frameTween(targetCFrame)
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local vehiclesFolder = workspace:FindFirstChild("Vehicles")
	if not vehiclesFolder then
		warn("Vehicles klasörü bulunamadı.")
		return
	end

	local vehicle = vehiclesFolder:FindFirstChild(player.Name)
	if not vehicle then
		warn("Oyuncuya ait araç bulunamadı.")
		return
	end

	local driveSeat = vehicle:FindFirstChild("DriveSeat")
	if not driveSeat or not driveSeat:IsA("Seat") then
		warn("DriveSeat bulunamadı veya uygun değil.")
		return
	end

	if not vehicle.PrimaryPart then
		local body = vehicle:FindFirstChild("Body")
		if body then
			local mass = body:FindFirstChild("Mass")
			if mass then
				vehicle.PrimaryPart = mass
			else
				warn("Body içinde 'Mass' bulunamadı.")
				return
			end
		else
			warn("Araç içinde 'Body' bulunamadı.")
			return
		end
	end

	driveSeat:Sit(humanoid)
	task.wait(0.1)

	local originalProps = {}
	for _, part in pairs(vehicle:GetDescendants()) do
		if part:IsA("BasePart") then
			originalProps[part] = {
				Velocity = part.Velocity,
				RotVelocity = part.RotVelocity,
				AssemblyLinearVelocity = part.AssemblyLinearVelocity,
				AssemblyAngularVelocity = part.AssemblyAngularVelocity
			}
			part.Velocity = Vector3.zero
			part.RotVelocity = Vector3.zero
			part.AssemblyLinearVelocity = Vector3.zero
			part.AssemblyAngularVelocity = Vector3.zero
		end
	end

	local function createTween(startCF, endCF)
		local distance = (endCF.Position - startCF.Position).Magnitude
		local duration = distance / _G.flightSpeed

		local cframe = Instance.new("CFrameValue")
		cframe.Value = startCF

		cframe.Changed:Connect(function()
			if vehicle.PrimaryPart then
				vehicle:SetPrimaryPartCFrame(cframe.Value)

				for _, part in pairs(vehicle:GetDescendants()) do
					if part:IsA("BasePart") then
						part.Velocity = Vector3.zero
						part.RotVelocity = Vector3.zero
						part.AssemblyLinearVelocity = Vector3.zero
						part.AssemblyAngularVelocity = Vector3.zero
					end
				end
			end
		end)

		local tween = TweenService:Create(cframe, TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {
			Value = endCF
		})

		return tween, cframe
	end

	local function smoothMove(startCF, endCF)
		local tween, cframe = createTween(startCF, endCF)
		tween:Play()
		tween.Completed:Wait()
		cframe:Destroy()

		if humanoid.SeatPart ~= driveSeat then
			driveSeat:Sit(humanoid)
			task.wait(0.1)
		end
	end

	-- Sabit yükseklik belirle
	local fixedY = -2.30769644

	-- First move horizontally at fixed Y
	local startCF = vehicle.PrimaryPart.CFrame
	local fixedStart = CFrame.new(Vector3.new(startCF.Position.X, fixedY, startCF.Position.Z), startCF.LookVector + Vector3.new(0, 0, 1))
	local fixedTarget = CFrame.new(Vector3.new(targetCFrame.Position.X, fixedY, targetCFrame.Position.Z), targetCFrame.LookVector + Vector3.new(0, 0, 1))

	smoothMove(fixedStart, fixedTarget)

	task.wait(0.2)

	-- Then move to the actual target Y position
	if math.abs(targetCFrame.Position.Y - fixedY) > 0.1 then
		local finalTarget = CFrame.new(Vector3.new(targetCFrame.Position.X, targetCFrame.Position.Y, targetCFrame.Position.Z), targetCFrame.LookVector + Vector3.new(0, 0, 1))
		smoothMove(fixedTarget, finalTarget)
		task.wait(0.2)
	end

	for part, props in pairs(originalProps) do
		if part and part.Parent then
			part.Velocity = props.Velocity
			part.RotVelocity = props.RotVelocity
			part.AssemblyLinearVelocity = props.AssemblyLinearVelocity
			part.AssemblyAngularVelocity = props.AssemblyAngularVelocity
		end
	end

	vehicle:SetPrimaryPartCFrame(targetCFrame)
	driveSeat:Sit(humanoid)

end

Tab3:AddSlider({
    Name = "Teleport Speed",
    Min = 30,
    Max = 300,
    Default = 190,
    Increment = 1,
    ValueName = "Speed",
    Callback = function(value)
        _G.flightSpeed = value
    end
})

-- Gemeinsame Bewegungsfunktion
local function moveVehicle(vehicle, targetCFrame)
    if not vehicle or not targetCFrame then return end

    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local driveSeat = vehicle:FindFirstChild("DriveSeat")

    if not driveSeat or not humanoid then return end
    
    -- Ensure we're in the vehicle
    driveSeat:Sit(humanoid)
    task.wait(0.1)
    
    -- Set primary part if needed
    if not vehicle.PrimaryPart then
        vehicle.PrimaryPart = driveSeat
    end

    -- Store original properties
    local originalProperties = {}
    for _, part in pairs(vehicle:GetDescendants()) do
        if part:IsA("BasePart") then
            originalProperties[part] = {
                Velocity = part.Velocity,
                RotVelocity = part.RotVelocity,
                AssemblyLinearVelocity = part.AssemblyLinearVelocity,
                AssemblyAngularVelocity = part.AssemblyAngularVelocity
            }
            -- Reset velocities to prevent glitching
            part.Velocity = Vector3.new(0, 0, 0)
            part.RotVelocity = Vector3.new(0, 0, 0)
            part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        end
    end

    local function createTween(startCF, endCF, isDescending)
        local distance = (endCF.Position - startCF.Position).Magnitude
        local tweenInfo = TweenInfo.new(
            distance / (isDescending and (_G.flightSpeed * 0.7) or _G.flightSpeed),
            Enum.EasingStyle.Linear,  -- Changed to Linear for consistent speed
            Enum.EasingDirection.InOut
        )
        
        local cframe = Instance.new("CFrameValue")
        cframe.Value = startCF
        
        cframe.Changed:Connect(function()
            if vehicle.PrimaryPart then
                vehicle:SetPrimaryPartCFrame(cframe.Value)
                
                -- Keep resetting velocities during movement to prevent glitching
                for _, part in pairs(vehicle:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Velocity = Vector3.new(0, 0, 0)
                        part.RotVelocity = Vector3.new(0, 0, 0)
                        part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    end
                end
            end
        end)
        
        local tween = TweenService:Create(cframe, tweenInfo, {
            Value = endCF
        })
        
        return tween, cframe
    end

    local function smoothMove(startCF, endCF, isDescending)
        local tween, cframe = createTween(startCF, endCF, isDescending)
        tween:Play()
        tween.Completed:Wait()
        cframe:Destroy()
        
        if humanoid.SeatPart ~= driveSeat then
            driveSeat:Sit(humanoid)
            task.wait(0.1)
        end
    end

    -- First go up high
    local startCF = vehicle.PrimaryPart.CFrame
    local upPos = startCF * CFrame.new(0, 350, 0)
    smoothMove(startCF, upPos, false)
    task.wait(0.1)

    -- Move horizontally at height
    local highTargetPos = CFrame.new(
        Vector3.new(targetCFrame.Position.X, upPos.Position.Y, targetCFrame.Position.Z),
        Vector3.new(targetCFrame.Position.X, upPos.Position.Y, targetCFrame.Position.Z) + targetCFrame.LookVector
    )
    smoothMove(vehicle.PrimaryPart.CFrame, highTargetPos, false)
    task.wait(0.2)

    -- Finally go down to target
    smoothMove(vehicle.PrimaryPart.CFrame, targetCFrame, true)
    
    -- Restore original properties after a small delay
    task.wait(0.2)
    for part, props in pairs(originalProperties) do
        if part and part.Parent then
            part.Velocity = props.Velocity
            part.RotVelocity = props.RotVelocity
            part.AssemblyLinearVelocity = props.AssemblyLinearVelocity
            part.AssemblyAngularVelocity = props.AssemblyAngularVelocity
        end
    end

    -- Final position check
    vehicle:SetPrimaryPartCFrame(targetCFrame)
    driveSeat:Sit(humanoid)
end

-- Teleport zu Dealer
Tab3:AddButton({
    Name = "Teleport to Nearest Dealer",
    Callback = function()
        local character = player.Character or player.CharacterAdded:Wait()
        local vehicle = workspace.Vehicles:FindFirstChild(player.Name)
        if not vehicle then return end

        local dealers = workspace:FindFirstChild("Dealers")
        if not dealers then return end

        local closest, shortest = nil, math.huge
        for _, dealer in pairs(dealers:GetChildren()) do
            if dealer:FindFirstChild("Head") then
                local dist = (character.HumanoidRootPart.Position - dealer.Head.Position).Magnitude
                if dist < shortest then
                    shortest = dist
                    closest = dealer.Head
                end
            end
        end
        if not closest then return end

        frameTween(closest.CFrame + Vector3.new(0, 5, 0))
    end
})

-- Teleport zu robbarem Vending Machine
Tab3:AddButton({
    Name = "TP to Robbable Vending Machine",
    Callback = function()
        local character = player.Character or player.CharacterAdded:Wait()
        local vehicle = workspace.Vehicles:FindFirstChild(player.Name)
        local machines = workspace:FindFirstChild("Robberies") and workspace.Robberies:FindFirstChild("VendingMachines")
        if not vehicle or not machines then return end

        local closest, shortest = nil, math.huge
        for _, model in pairs(machines:GetChildren()) do
            for _, part in pairs(model:GetChildren()) do
                if part:IsA("Part") and part.Color == Color3.fromRGB(73, 147, 0) then
                    local dist = (character.HumanoidRootPart.Position - part.Position).Magnitude
                    if dist < shortest then
                        shortest = dist
                        closest = part
                    end
                end
            end
        end
        if not closest then
            OrionLib:MakeNotification({
                Name = "Not Founded",
                Content = "Robbable Vending Machine not Founded",
                Image = "rbxassetid://4483345998",
                Time = 5
            })
            return
        end

        frameTween(closest.CFrame)
    end
})



local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer

local flightSpeed = 190 -- Langsamer machen (z. B. 20 statt 60)

Tab3:AddDropdown({
    Name = "Normal Places",
    Default = "1",
    Options = {"Prison Out", "Prison In", "Hospital", "Tuner", "Dealership", "Fire Station", "Smuggler (near clothing store)", "Truck Company", "Bus Company"},
    Callback = function(Value)
        local locations = {
            ["Prison Out"] = CFrame.new(-615.5797729492188, 5.289504051208496, 2862.23681640625),
            ["Prison In"] = CFrame.new(-572.1055297851562, 6.382352352142334, 3061.3740234375),
            ["Fire Station"] = CFrame.new(-1025.360595703125, 4.500086784362793, 3899.155029296875),
            ["Parking Garage"] = CFrame.new(-1001.6951904296875, 10.850526809692383, 3655.860595703125),
            ["Truck Company"] = CFrame.new(704.4508666992188, 4.229461669921875, 1479.9267578125),
            ["Smuggler (near clothing store)"] = CFrame.new(796.5571899414062, -18.67022705078125, -1526.3787841796875),
            ["Tuner"] = CFrame.new(-1438.34705, 5.35521317, 171.125198, 0.0264777429, 0.0146148987, 0.999542534, -0.0202042889, 0.999696672, -0.0140819438, -0.9994452, -0.0198221896, 0.0267649963),
            ["Bus Company"] = CFrame.new(-1682.2969970703125, 8.779464721679688, -1273.07763671875),
            ["Hospital"] = CFrame.new(-278.833740234375, 7.7454142570495605, 1085.7965087890625),
            ["Polica Station"] = CFrame.new(-1702.70166015625, 4.607900142669678, 2723.564697265625),
            ["Dealership"] = CFrame.new(-1415.6986083984375, 4.552238464355469, 940.5262451171875),
        }

        local targetCFrame = locations[Value]
        if not targetCFrame then return end

        local vehicle = workspace:FindFirstChild("Vehicles") and workspace.Vehicles:FindFirstChild(player.Name)
        if not vehicle or not vehicle:IsA("Model") then return end

        frameTween(targetCFrame)
    end
})

Tab3:AddDropdown({
    Name = "Robbery Places",
    Default = "1",
    Options = {"Bank", "Jewellery", "Erwin Club", "Gas-N-Go Fuel", "Ares Fuel", "Tool Shop", "Farm Shop", "Osso Fuel", "Container Ship", "Clothing Store"},
    Callback = function(Value)
        local locations = {
            ["Bank"] = CFrame.new(-1183.296, 10.912, 3228.297),
            ["Jewellery"] = CFrame.new(-407.536, 21.950, 3516.854),
            ["Erwin Club"] = CFrame.new(-1856.962, 5.706, 2990.518),
            ["Gas-N-Go Fuel"] = CFrame.new(-1560.674, 3.944, 3813.656),
            ["Ares Fuel"] = CFrame.new(-824.447, 4.182, 1512.941),
            ["Tool Shop"] = CFrame.new(-767.815, 4.374, 663.494),
            ["Farm Shop"] = CFrame.new(-887.220, 5.831, -1150.356),
            ["Osso Fuel"] = CFrame.new(-27.464, 5.245, -749.413),
            ["Container Ship"] = CFrame.new(1191.836, 29.550, 2140.703),
            ["Clothing Store"] = CFrame.new(440.400, 5.520, -1438.111),
        }

        local targetCFrame = locations[Value]
        if not targetCFrame then return end

        local vehicle = workspace:FindFirstChild("Vehicles") and workspace.Vehicles:FindFirstChild(player.Name)
        if not vehicle or not vehicle:IsA("Model") then return end

        frameTween(targetCFrame)
    end
})

local Tab4 = Window:MakeTab({
    Name = "│ESP",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local espSettings = {
    showName = false,
    showWanted = false,
    useTeamColor = false,
    showTracer = false,
    showChams = false,
    showBox = false,
    showPlayerHighlight = false,
    showCarOwner = false,
    showCarTeam = false,
    showCarWanted = false,
    nameSize = 14,
    wantedSize = 14,
    tracerSize = 2,  
    chamsSize = 1,
    showDistance = false
}

local espObjects = {}
local wantedPlayers = {}
local rainbowSpeed = 5
local rainbowEnabled = false

-- Only connect to wanted event if wanted ESP is enabled
local wantedEventConnection = nil

local function setupWantedEvent()
    -- Disconnect existing connection if any
    if wantedEventConnection then
        wantedEventConnection:Disconnect()
        wantedEventConnection = nil
    end
    
    -- Only connect if wanted ESP is enabled
    if espSettings.showWanted or espSettings.showCarWanted then
        wantedEventConnection = wantedRemoteEvent.OnClientEvent:Connect(function(eventData)
            if typeof(eventData) == "table" then
                table.clear(wantedPlayers)
                for name in pairs(eventData) do
                    if name ~= LocalPlayer.Name then
                        wantedPlayers[name] = true
                    end
                end
            end
        end)
    end
end

-- Function to properly clean up ESP objects
local function cleanupESPObjects(player)
    if espObjects[player] then
        -- Clean up Drawing objects
        if espObjects[player].Tracer then 
            espObjects[player].Tracer:Remove() 
        end
        if espObjects[player].Box then 
            espObjects[player].Box:Remove() 
        end
        
        -- Clean up BillboardGui and Highlight
        if espObjects[player].Billboard then 
            espObjects[player].Billboard:Destroy() 
        end
        if espObjects[player].Cham then 
            espObjects[player].Cham:Destroy() 
        end
        
        espObjects[player] = nil
    end
end

local function CreateESP(player)
    if player == LocalPlayer then return end
    cleanupESPObjects(player)

    local function setup()
        local character = player.Character
        if not character then return end

        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then
            hrp = character:WaitForChild("HumanoidRootPart", 5)
            if not hrp then return end
        end

        -- Clean up any existing ESP objects
        if hrp:FindFirstChild("ESP") then hrp.ESP:Destroy() end
        if hrp:FindFirstChild("Cham") then hrp.Cham:Destroy() end

        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESP"
        billboard.Adornee = hrp
        billboard.Size = UDim2.new(0, 200, 0, 100)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = hrp

        local function createLine(name, size)
            local label = Instance.new("TextLabel")
            label.Name = name
            label.Size = UDim2.new(1, 0, 0, size + 2)
            label.Position = UDim2.new(0, 0, 0, 0)
            label.BackgroundTransparency = 1
            label.TextStrokeTransparency = 0.5
            label.Font = Enum.Font.GothamBold
            label.TextScaled = false
            label.TextSize = size
            label.Text = ""
            label.TextColor3 = Color3.new(1, 1, 1)
            label.TextWrapped = true
            label.Parent = billboard
            return label
        end

        local tracerLine = Drawing.new("Line")
        tracerLine.Thickness = espSettings.tracerSize
        tracerLine.Color = Color3.new(1, 1, 1)
        tracerLine.Visible = false

        local highlight = Instance.new("Highlight")
        highlight.Name = "Cham"
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 1 - (espSettings.chamsSize/10)
        highlight.OutlineColor = Color3.new(0, 0, 0)
        highlight.Enabled = false
        highlight.Adornee = character
        highlight.Parent = hrp

        local box = Drawing.new("Square")
        box.Visible = false
        box.Thickness = 1
        box.Transparency = 1
        box.Color = Color3.new(1, 0, 0)

        espObjects[player] = {
            Billboard = billboard,
            Lines = {
                Wanted = createLine("Wanted", espSettings.wantedSize),
                Name = createLine("Name", espSettings.nameSize),
                Distance = createLine("Distance", espSettings.nameSize - 2)
            },
            Tracer = tracerLine,
            Cham = highlight,
            Box = box
        }
    end

    -- Handle character added
    player.CharacterAdded:Connect(function()
        task.wait(1)
        setup()
    end)

    -- Handle character removal
    player.CharacterRemoving:Connect(function()
        cleanupESPObjects(player)
    end)

    if player.Character then
        task.spawn(function()
            task.wait(1)
            setup()
        end)
    end
end

local function UpdateESP()
    -- Car ESP
    local vehiclesFolder = workspace:FindFirstChild("Vehicles")
    if vehiclesFolder and (espSettings.showCarOwner or espSettings.showCarTeam or espSettings.showCarWanted) then
        -- Clean up old ESP
        for _, vehicle in pairs(vehiclesFolder:GetChildren()) do
            if vehicle:IsA("Model") and vehicle:FindFirstChild("DriveSeat") then
                local driveSeat = vehicle:FindFirstChild("DriveSeat")
                if driveSeat:FindFirstChild("CarESP") then
                    driveSeat.CarESP:Destroy()
                end
            end
        end

        -- Create new ESP only for enabled features
        for _, player in pairs(game.Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            
            local vehicle = vehiclesFolder:FindFirstChild(player.Name)
            if vehicle and vehicle:IsA("Model") and vehicle:FindFirstChild("DriveSeat") then
                local driveSeat = vehicle:FindFirstChild("DriveSeat")
                
                local billboard = Instance.new("BillboardGui")
                billboard.Name = "CarESP"
                billboard.Adornee = driveSeat
                billboard.Size = UDim2.new(0, 200, 0, 100)
                billboard.StudsOffset = Vector3.new(0, 6, 0)
                billboard.AlwaysOnTop = true
                billboard.Parent = driveSeat

                local function createLine(name, size)
                    local label = Instance.new("TextLabel")
                    label.Name = name
                    label.Size = UDim2.new(1, 0, 0, size + 2)
                    label.Position = UDim2.new(0, 0, 0, 0)
                    label.BackgroundTransparency = 1
                    label.TextStrokeTransparency = 0.5
                    label.Font = Enum.Font.GothamBold
                    label.TextScaled = false
                    label.TextSize = size
                    label.Text = ""
                    label.TextColor3 = Color3.new(1, 1, 1)
                    label.TextWrapped = true
                    label.Parent = billboard
                    return label
                end

                local lines = {
                    Owner = createLine("Owner", espSettings.nameSize),
                    Team = createLine("Team", espSettings.nameSize),
                    Wanted = createLine("Wanted", espSettings.wantedSize)
                }

                local y = 0

                if espSettings.showCarOwner then
                    lines.Owner.Text = "Owner: " .. player.Name
                    lines.Owner.Position = UDim2.new(0, 0, 0, y)
                    lines.Owner.Visible = true
                    y = y + espSettings.nameSize + 2
                else
                    lines.Owner.Visible = false
                end

                if espSettings.showCarTeam then
                    local teamName = player.Team and player.Team.Name or "No Team"
                    lines.Team.Text = "Team: " .. teamName
                    lines.Team.Position = UDim2.new(0, 0, 0, y)
                    lines.Team.Visible = true
                    if player.Team and player.Team.TeamColor then
                        lines.Team.TextColor3 = player.Team.TeamColor.Color
                    else
                        lines.Team.TextColor3 = Color3.new(1, 1, 1)
                    end
                    y = y + espSettings.nameSize + 2
                else
                    lines.Team.Visible = false
                end

                if espSettings.showCarWanted and wantedPlayers[player.Name] then
                    lines.Wanted.Text = "│ WANTED │"
                    if rainbowEnabled then
                        local hue = (tick() * rainbowSpeed) % 1
                        lines.Wanted.TextColor3 = Color3.fromHSV(hue, 1, 1)
                    else
                        lines.Wanted.TextColor3 = Color3.new(1, 0, 0)
                    end
                    lines.Wanted.Position = UDim2.new(0, 0, 0, y)
                    lines.Wanted.Visible = true
                else
                    lines.Wanted.Visible = false
                end
            end
        end
    end

    -- Player ESP
    for player, data in pairs(espObjects) do
        if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if data.Tracer then data.Tracer.Visible = false end
            if data.Cham then data.Cham.Enabled = false end
            if data.Box then data.Box.Visible = false end
            continue
        end

        local hrp = player.Character.HumanoidRootPart
        local lines = data.Lines
        local y = 0

        -- Stack labels in order: Name, Wanted, Distance
        if espSettings.showName then
            lines.Name.Text = player.Name
            lines.Name.TextColor3 = espSettings.useTeamColor and (player.Team and player.Team.TeamColor.Color or Color3.new(1,1,1)) or Color3.new(1,1,1)
            lines.Name.Position = UDim2.new(0, 0, 0, y)
            lines.Name.TextSize = espSettings.nameSize
            lines.Name.Visible = true
            y = y + espSettings.nameSize + 2
        else
            lines.Name.Visible = false
        end

        if espSettings.showWanted and wantedPlayers[player.Name] then
            lines.Wanted.Text = "│ WANTED │"
            if rainbowEnabled then
                local hue = (tick() * rainbowSpeed) % 1
                lines.Wanted.TextColor3 = Color3.fromHSV(hue, 1, 1)
            else
                lines.Wanted.TextColor3 = Color3.fromRGB(255, 215, 0)
            end
            lines.Wanted.Position = UDim2.new(0, 0, 0, y)
            lines.Wanted.TextSize = espSettings.wantedSize
            lines.Wanted.Visible = true
            y = y + espSettings.wantedSize + 2
        else
            lines.Wanted.Visible = false
        end

        if espSettings.showDistance and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local localHRP = LocalPlayer.Character.HumanoidRootPart
            local dist = (hrp.Position - localHRP.Position).Magnitude
            lines.Distance.Text = string.format("[%dm]", math.floor(dist + 0.5))
            lines.Distance.Position = UDim2.new(0, 0, 0, y)
            if espSettings.useTeamColor and player.Team and player.Team.TeamColor then
                lines.Distance.TextColor3 = player.Team.TeamColor.Color
            else
                lines.Distance.TextColor3 = Color3.new(1, 1, 1)
            end
            lines.Distance.TextSize = espSettings.nameSize - 2
            lines.Distance.Visible = true
            y = y + (espSettings.nameSize - 2) + 2
        else
            lines.Distance.Visible = false
        end

        if espSettings.showTracer then
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                data.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                data.Tracer.To = Vector2.new(pos.X, pos.Y)
                data.Tracer.Color = espSettings.useTeamColor and (player.Team and player.Team.TeamColor.Color or Color3.new(1,1,1)) or Color3.new(1,1,1)
                data.Tracer.Thickness = espSettings.tracerSize
                data.Tracer.Visible = true
            else
                data.Tracer.Visible = false
            end
        else
            data.Tracer.Visible = false
        end

        if espSettings.showPlayerHighlight then
            data.Cham.Enabled = true
            data.Cham.FillColor = (espSettings.useTeamColor and player.Team and player.Team.TeamColor.Color) or Color3.new(1,1,1)
            data.Cham.FillTransparency = 0
            data.Cham.OutlineColor = (espSettings.useTeamColor and player.Team and player.Team.TeamColor.Color) or Color3.new(1,1,1)
            data.Cham.OutlineTransparency = 0
        elseif espSettings.showChams then
            data.Cham.Enabled = true
            data.Cham.FillColor = (espSettings.useTeamColor and player.Team and player.Team.TeamColor.Color) or Color3.new(1,1,1)
            data.Cham.FillTransparency = 0.5
            data.Cham.OutlineColor = Color3.new(0,0,0)
            data.Cham.OutlineTransparency = 1 - (espSettings.chamsSize/10)
        else
            data.Cham.Enabled = false
        end

        if espSettings.showBox then
            local character = player.Character
            local rootPart = character.HumanoidRootPart

            if espSettings.useTeamColor and player.Team then
                data.Box.Color = player.Team.TeamColor.Color
            else
                data.Box.Color = Color3.new(1, 0, 0)
            end

            local cframe, size = character:GetBoundingBox()
            local adjustedHeight = math.clamp(size.Y, 4, 7)
            local adjustedWidth = math.clamp(size.X, 2, 4)
            size = Vector3.new(adjustedWidth, adjustedHeight, size.Z)

            local minScreenPos, maxScreenPos = Vector2.new(math.huge, math.huge), Vector2.new(-math.huge, -math.huge)
            local allCornersOnScreen = true

            for _, corner in ipairs({
                Vector3.new(-size.X / 2, size.Y / 2, -size.Z / 2),
                Vector3.new(size.X / 2, size.Y / 2, -size.Z / 2),
                Vector3.new(-size.X / 2, -size.Y / 2, -size.Z / 2),
                Vector3.new(size.X / 2, -size.Y / 2, -size.Z / 2),
                Vector3.new(-size.X / 2, size.Y / 2, size.Z / 2),
                Vector3.new(size.X / 2, size.Y / 2, size.Z / 2),
                Vector3.new(-size.X / 2, -size.Y / 2, size.Z / 2),
                Vector3.new(size.X / 2, -size.Y / 2, size.Z / 2),
            }) do
                local worldPos = (cframe * corner)
                local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(worldPos)
                if onScreen and screenPos.Z > 0 then
                    minScreenPos = Vector2.new(
                        math.min(minScreenPos.X, screenPos.X),
                        math.min(minScreenPos.Y, screenPos.Y)
                    )
                    maxScreenPos = Vector2.new(
                        math.max(maxScreenPos.X, screenPos.X),
                        math.max(maxScreenPos.Y, screenPos.Y)
                    )
                else
                    allCornersOnScreen = false
                    break
                end
            end

            if allCornersOnScreen and (maxScreenPos - minScreenPos).Magnitude > 5 then
                data.Box.Size = maxScreenPos - minScreenPos
                data.Box.Position = minScreenPos
                data.Box.Visible = true
            else
                data.Box.Visible = false
            end
        else
            data.Box.Visible = false
        end
    end
end

Tab4:AddToggle({
    Name = "Name ESP",
    Default = espSettings.showName,
    Callback = function(Value)
        espSettings.showName = Value
    end
})

Tab4:AddToggle({
    Name = "WANTED ESP",
    Default = espSettings.showWanted,
    Callback = function(Value)
        espSettings.showWanted = Value
        setupWantedEvent()
    end
})

Tab4:AddToggle({
    Name = "Team Color",
    Default = espSettings.useTeamColor,
    Callback = function(Value)
        espSettings.useTeamColor = Value
    end
})

Tab4:AddToggle({
    Name = "Tracer ESP",
    Default = espSettings.showTracer,
    Callback = function(Value)
        espSettings.showTracer = Value
    end
})

Tab4:AddToggle({
    Name = "Box ESP",
    Default = espSettings.showBox,
    Callback = function(Value)
        espSettings.showBox = Value
    end
})

Tab4:AddToggle({
    Name = "Distance ESP",
    Default = espSettings.showDistance,
    Callback = function(Value)
        espSettings.showDistance = Value
    end
})

Tab4:AddToggle({
    Name = "Player Highlight ESP",
    Default = espSettings.showPlayerHighlight,
    Callback = function(Value)
        espSettings.showPlayerHighlight = Value
    end
})

Tab4:AddLabel("Settings")

Tab4:AddToggle({
    Name = "Rainbow WANTED",
    Default = false,
    Callback = function(Value)
        rainbowEnabled = Value
    end
})

Tab4:AddSlider({
    Name = "Rainbow Speed",
    Min = 1,
    Max = 10,
    Default = rainbowSpeed,
    Increment = 1,
    Callback = function(Value)
        rainbowSpeed = Value
    end
})

Tab4:AddSlider({
    Name = "Name Size",
    Min = 10,
    Max = 25,
    Default = espSettings.nameSize,
    Increment = 1,
    Callback = function(Value)
        espSettings.nameSize = Value
        for _, player in ipairs(Players:GetPlayers()) do
            if espObjects[player] then
                espObjects[player].Lines.Name.TextSize = Value
            end
        end
    end
})

Tab4:AddSlider({
    Name = "WANTED Size",
    Min = 10,
    Max = 25,
    Default = espSettings.wantedSize,
    Increment = 1,
    Callback = function(Value)
        espSettings.wantedSize = Value
        for _, player in ipairs(Players:GetPlayers()) do
            if espObjects[player] then
                espObjects[player].Lines.Wanted.TextSize = Value
            end
        end
    end
})

Tab4:AddSlider({
    Name = "Tracer Size (Thickness)",
    Min = 1,
    Max = 5,
    Default = espSettings.tracerSize,
    Increment = 1,
    Callback = function(Value)
        espSettings.tracerSize = Value
        for _, player in ipairs(Players:GetPlayers()) do
            if espObjects[player] then
                espObjects[player].Tracer.Thickness = Value
            end
        end
    end
})



-- Connect to RunService for ESP updates
RunService.RenderStepped:Connect(function()
    UpdateESP()
end)

-- Connect to player events
Players.PlayerAdded:Connect(function(player)
    CreateESP(player)
end)

Players.PlayerRemoving:Connect(function(player)
    cleanupESPObjects(player)
end)

-- Setup ESP for existing players
for _, player in ipairs(Players:GetPlayers()) do
    CreateESP(player)
end

--// ===================================================
--//  Aimbot & Auto Shoot
--// ===================================================


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

--------------------------------------------------------------------------------
-- UNIFIED TAB: AIMBOT & AUTO SHOOT 
--------------------------------------------------------------------------------
local AimTab = Window:MakeTab({
    Name = "│Aim",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

local AimMethod = "Auto Shoot" -- Default
local AimMethods = {"Auto Shoot", "Aimbot"}

-- Aim Settings Section
local AimSettingsSection = AimTab:AddSection({
    Name = "Aim Settings"
})

AimSettingsSection:AddDropdown({
    Name = "Aim Method",
    Options = AimMethods,
    Default = "Auto Shoot",
    Callback = function(Value)
        AimMethod = Value
    end
})

-- Shared state for toggles and settings
local AimEnabled = false
local PredictionEnabled = false
local TeamCheck = false
local KnockedCheck = false
local VisibleCheck = false
local FovEnabled = false
local FovSize = 200
local FovColorOn = Color3.fromRGB(0, 255, 0)
local FovColorOff = Color3.fromRGB(255, 0, 0)
local SelectedBones = { "Head", "HumanoidRootPart" }
local Bones = { "Head", "HumanoidRootPart", "Torso", "Left Arm", "Right Arm" }
local smoothing = 0.5
local predictionFactor = 0.1575
local mobileModeEnabled = false
local mobileButton, mobileGui

-- Remove individual toggles for TeamCheck, KnockedCheck, VisibleCheck, PredictionEnabled
-- Add MultiSelect for checks
local CheckOptions = {"Team Check", "Knocked Check", "Visible Check", "Prediction"}
local SelectedChecks = {}

AimSettingsSection:AddMultiSelect({
    Name = "Checks",
    Options = CheckOptions,
    Default = {},
    Flag = "ChecksMultiSelect",
    Callback = function(Value)
        SelectedChecks = Value or {}
        TeamCheck = false
        KnockedCheck = false
        VisibleCheck = false
        PredictionEnabled = false
        for _, v in ipairs(SelectedChecks) do
            if v == "Team Check" then TeamCheck = true end
            if v == "Knocked Check" then KnockedCheck = true end
            if v == "Visible Check" then VisibleCheck = true end
            if v == "Prediction" then PredictionEnabled = true end
        end
    end
})

AimSettingsSection:AddMultiSelect({
    Name = "Aimbot Bones",
    Options = Bones,
    Default = {"Head"},
    Flag = "AimbotBonesMultiSelect",
    Callback = function(Value)
        if typeof(Value) == "table" then
            SelectedBones = Value
        else
            SelectedBones = {"Head", "HumanoidRootPart"}
        end
    end
})

AimSettingsSection:AddSlider({
    Name = "Change Bone Interval (s)",
    Min = 0.1,
    Max = 2,
    Default = 0.5,
    Increment = 0.05,
    Callback = function(Value)
        predictionFactor = Value
    end
})

AimSettingsSection:AddSlider({
    Name = "Smoothness (Aimbot)",
    Min = 1,
    Max = 10,
    Default = 5,
    Increment = 1,
    Color = Color3.fromRGB(255,255,255),
    ValueName = "",
    Callback = function(value)
        smoothing = math.max((10 - value) / 10, 0.01)
    end
})

-- FOV Settings Section
local FOVSettingsSection = AimTab:AddSection({
    Name = "FOV Settings"
})

FOVSettingsSection:AddToggle({
    Name = "Enable FOV",
    Default = false,
    Callback = function(Value)
        FovEnabled = Value
    end
})

FOVSettingsSection:AddSlider({
    Name = "FOV Size",
    Min = 50,
    Max = 500,
    Default = 200,
    Increment = 10,
    Callback = function(Value)
        FovSize = Value
    end
})

FOVSettingsSection:AddColorpicker({
    Name = "FOV Color (ON)",
    Default = FovColorOn,
    Callback = function(Value)
        FovColorOn = Value
    end
})

FOVSettingsSection:AddColorpicker({
    Name = "FOV Color (OFF)",
    Default = FovColorOff,
    Callback = function(Value)
        FovColorOff = Value
    end
})

-- Controls Section
local ControlsSection = AimTab:AddSection({
    Name = "Controls"
})

ControlsSection:AddToggle({
    Name = "Mobile Support",
    Default = false,
    Callback = function(Value)
        mobileModeEnabled = Value
        if mobileModeEnabled then
            createMobileGui()
        else
            removeMobileGui()
        end
    end
})



ControlsSection:AddBind({
    Name = "Aim Keybind",
    Default = Enum.KeyCode.V,
    Hold = false,
    Callback = function()
        AimEnabled = not AimEnabled
    end
})

-- FOV Drawing
local FovCircle = Drawing.new("Circle")
FovCircle.Visible = FovEnabled
FovCircle.Radius = FovSize
FovCircle.Color = FovColorOff
FovCircle.Filled = false
FovCircle.Thickness = 2

-- Update FOV circle color and position
local function updateFovCircle()
    if FovEnabled then
        FovCircle.Visible = true
        FovCircle.Position = Vector2.new(
            Workspace.CurrentCamera.ViewportSize.X / 2,
            Workspace.CurrentCamera.ViewportSize.Y / 2
        )
        FovCircle.Radius = FovSize
        FovCircle.Color = AimEnabled and FovColorOn or FovColorOff
    else
        FovCircle.Visible = false
    end
end

RunService.RenderStepped:Connect(updateFovCircle)

-- Add aimbot bone cycling
local currentAimbotBoneIndex = 1
local lastBoneChangeTime = tick()

-- In aimbot logic, cycle through bones at the set interval
local function getCurrentAimbotBone()
    if #SelectedBones == 0 then return "Head" end
    if tick() - lastBoneChangeTime >= predictionFactor then
        currentAimbotBoneIndex = currentAimbotBoneIndex % #SelectedBones + 1
        lastBoneChangeTime = tick()
    end
    return SelectedBones[currentAimbotBoneIndex] or "Head"
end

-- Improved aimbot logic
local function isValidTarget(player)
    if player == LocalPlayer or not player.Character then return false end
    local targetPart = player.Character:FindFirstChild(getCurrentAimbotBone())
    if not targetPart then return false end
    if KnockedCheck and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid.Health <= (humanoid.MaxHealth * 0.2) then return false end
    end
    if TeamCheck and player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then
        return false
    end
    if VisibleCheck then
        local origin = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position
        if origin then
            local direction = (targetPart.Position - origin).Unit * 1000
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = { LocalPlayer.Character }
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local result = Workspace:Raycast(origin, direction, params)
            if not (result and result.Instance and result.Instance:IsDescendantOf(targetPart.Parent)) then
                return false
            end
        end
    end
    return true
end

local function getBestAimbotTarget()
    local bestTarget = nil
    local bestDist = math.huge
    local screenCenter = Workspace.CurrentCamera.ViewportSize / 2
    for _, player in ipairs(Players:GetPlayers()) do
        if isValidTarget(player) then
            local targetPart = player.Character[getCurrentAimbotBone()]
            local screenPoint, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(targetPart.Position)
            if onScreen then
                local dist = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
                if dist <= FovSize and dist < bestDist then
                    bestDist = dist
                    bestTarget = player
                end
            end
        end
    end
    return bestTarget
end

local function predictPosition(target)
    local bone = getCurrentAimbotBone()
    if target and target.Character and target.Character:FindFirstChild(bone) then
        local velocity = target.Character[bone].Velocity
        local position = target.Character[bone].Position
        return PredictionEnabled and (position + (velocity * predictionFactor)) or position
    end
    return nil
end

RunService.RenderStepped:Connect(function()
    if not AimEnabled then return end
    if AimMethod == "Aimbot" then
        if (UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)) or (mobileModeEnabled) then
            local currentTarget = getBestAimbotTarget()
            if currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild(getCurrentAimbotBone()) then
                local predictedPosition = predictPosition(currentTarget)
                if predictedPosition then
                    Workspace.CurrentCamera.CFrame = Workspace.CurrentCamera.CFrame:Lerp(CFrame.new(Workspace.CurrentCamera.CFrame.Position, predictedPosition), smoothing)
                end
            end
        end
    end
end)

-- Mobile Aimbot GUI
function removeMobileGui()
    if mobileGui then
        mobileGui:Destroy()
        mobileGui = nil
        mobileButton = nil
    end
end
function createMobileGui()
    if mobileGui then return end
    mobileGui = Instance.new("ScreenGui")
    mobileGui.Name = "MobileAimGui"
    mobileGui.Parent = Players.LocalPlayer:FindFirstChild("PlayerGui")
    mobileButton = Instance.new("TextButton")
    mobileButton.Size = UDim2.new(0, 200, 0, 50)
    mobileButton.Position = UDim2.new(0.5, -100, 0.75, 0)
    updateMobileButtonVisual()
    mobileButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    mobileButton.Font = Enum.Font.SourceSans
    mobileButton.TextSize = 24
    mobileButton.Parent = mobileGui
    Instance.new("UICorner", mobileButton)
    mobileButton.MouseButton1Click:Connect(function()
        AimEnabled = not AimEnabled
        updateMobileButtonVisual()
    end)
    local dragging = false
    local dragStart = nil
    local startPos = nil
    mobileButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mobileButton.Position
        end
    end)
    mobileButton.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            mobileButton.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
    mobileButton.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
end

function updateMobileButtonVisual()
    if not mobileButton then return end
    if AimEnabled then
        if AimMethod == "Aimbot" then
            mobileButton.Text = "Aimbot: ON"
        else
            mobileButton.Text = "Auto Shoot: ON"
        end
        mobileButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    else
        if AimMethod == "Aimbot" then
            mobileButton.Text = "Aimbot: OFF"
            mobileButton.BackgroundColor3 = Color3.fromRGB(0, 0, 255)
        else
            mobileButton.Text = "Auto Shoot: OFF"
            mobileButton.BackgroundColor3 = Color3.fromRGB(255, 128, 0)
        end
    end
end

OrionLib:Init() 

local Tab5 = Window:MakeTab({
	Name = "│Gun Mods",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

local WeaponNames = {
    "Glock 17", "G36", "MP5", "M58B", "Sniper", "M4 Carbine"
}

local NoRecoil = false
local FastBullet = false


local function getPlayerWeaponFolder()
    return workspace:FindFirstChild(LocalPlayer.Name)
end

local function hasWeaponEquipped()
    local weaponFolder = getPlayerWeaponFolder()
    if not weaponFolder then return false end
    
    for _, weaponName in ipairs(WeaponNames) do
        if weaponFolder:FindFirstChild(weaponName) then
            return true
        end
    end
    return false
end

-- Auto gun function
local function autoGun()
    if not AutoGun then return end
    if not hasWeaponEquipped() then return end -- Only work if player has a weapon
    
    -- Only shoot if left mouse is held down
    if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
        mouse1click()
    end
end

-- Start auto gun loop
spawn(function()
    while true do
        if FastBullet and AutoGun then
            autoGun()
        end
        task.wait()
    end
end)

-- Second loop for extra spam
spawn(function()
    while true do
        if FastBullet and AutoGun and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
            mouse1click()
        end
        task.wait()
    end
end)

RunService.Heartbeat:Connect(function()
    local weaponFolder = getPlayerWeaponFolder()
    if not weaponFolder then return end

    for _, weaponName in ipairs(WeaponNames) do
        local weapon = weaponFolder:FindFirstChild(weaponName)
        if weapon then
            if NoRecoil then
                pcall(function()
                    weapon:SetAttribute("Recoil", 0)
                    weapon:SetAttribute("Spread", 0)
                    weapon:SetAttribute("Instability", 0)
                    weapon:SetAttribute("RecoilAmount", 0)
                    weapon:SetAttribute("RecoilRecovery", 0)
                end)
            end

            if FastBullet then
                pcall(function()
                    weapon:SetAttribute("ShootDelay", 0)
                    weapon:SetAttribute("FireRate", 999)
                    weapon:SetAttribute("RateOfFire", 999)
                end)
            end

            if InfiniteAmmo then
                pcall(function()
                    weapon:SetAttribute("Ammo", 999)
                    weapon:SetAttribute("MaxAmmo", 999)
                    weapon:SetAttribute("CurrentAmmo", 999)
                    weapon:SetAttribute("ReserveAmmo", 999)
                end)
            end

            if InstantReload then
                pcall(function()
                    weapon:SetAttribute("ReloadTime", 0)
                    weapon:SetAttribute("ReloadSpeed", 999)
                    weapon:SetAttribute("ReloadDuration", 0)
                end)
            end
        end
    end
end)

Tab5:AddToggle({
    Name = "No Recoil",
    Default = false,
    Callback = function(Value)
        NoRecoil = Value
    end
})

Tab5:AddToggle({
    Name = "Fast Bullet",
    Default = false,
    Callback = function(Value)
        FastBullet = Value
    end
})

Tab5:AddToggle({
    Name = "No Instability",
    Default = false,
    Callback = function(Value)
        NoInstability = Value
    end
})

Tab5:AddToggle({
    Name = "No Spread",
    Default = false,
    Callback = function(Value)
        NoSpread = Value
    end
})

-----------
local Tab6 = Window:MakeTab({
	Name = "│Pro Mod's",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})
----------------------------

local function getCharacter()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    return character, humanoid
end

local character, humanoid = getCharacter()

local seatPartConnection

local function setupSeatPartListener()
    if seatPartConnection then
        seatPartConnection:Disconnect()
    end

    seatPartConnection = humanoid:GetPropertyChangedSignal("SeatPart"):Connect(function()
        local seatPart = humanoid.SeatPart
        if seatPart then
            local greatGrandParent = seatPart.Parent and seatPart.Parent.Parent and seatPart.Parent.Parent.Parent
            if greatGrandParent then
                local playerName = greatGrandParent.Name

                local targetPlayer = game.Players:FindFirstChild(playerName)
                if targetPlayer and targetPlayer.TeamColor == BrickColor.new("Bright blue") then
                    humanoid.Sit = false

                    local animateScript = character:FindFirstChild("Animate")
                    if animateScript then
                        animateScript.Enabled = false
                        wait(0.1)
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                        wait(0.1)
                        animateScript.Enabled = true
                    end
                end
            end
        end
    end)
end

Tab6:AddToggle({
    Name = "AutoEspace (Police Car)",
    Default = false,
    Callback = function(Value)
        if Value then
            setupSeatPartListener()
        else
            if seatPartConnection then
                seatPartConnection:Disconnect()
            end
        end
    end
})

player.CharacterAdded:Connect(function()
    wait(0.1)
    character, humanoid = getCharacter()
end)


Tab6:AddButton({
	Name = "Steal Nearest Bike",
	Callback = function()
		local player = game.Players.LocalPlayer
		local character = player.Character or player.CharacterAdded:Wait()
		local hrp = character:WaitForChild("HumanoidRootPart")

		local function isUUID(name)
			local pattern = "^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$"
			return string.match(name, pattern) ~= nil
		end

		local vehiclesFolder = workspace:WaitForChild("Vehicles")
		local function findNearestDriveSeat()
			local closestDistance = math.huge
			local closestSeat

			for _, vehicle in ipairs(vehiclesFolder:GetChildren()) do
				if isUUID(vehicle.Name) then
					local seat = vehicle:FindFirstChild("DriveSeat", true)
					if seat and seat:IsA("Seat") then
						local dist = (seat.Position - hrp.Position).Magnitude
						if dist < closestDistance then
							closestDistance = dist
							closestSeat = seat
						end
					end
				end
			end

			return closestSeat
		end

		local seat = findNearestDriveSeat()
		if seat then
			seat:Sit(character:WaitForChild("Humanoid"))
		end
	end    
})


Tab6:AddToggle({
    Name = "Anti-Arrest",
    Default = false,
    Callback = function(Value)
        repelActive = Value
        if repelActive then
        else
        end
    end    
})


Tab6:AddSlider({
    Name = "Safe Distance for Anti-Arrest",
    Min = 0,
    Max = 40,
    Default = 35,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Studs",
    Callback = function(Value)
        searchRadius = Value
        safeDistance = Value
    end    
})

local services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    TweenService = game:GetService("TweenService")
}

local localPlayer = services.Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local tweenCache = {}

local function updateCharacter()
    character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    hrp = character:WaitForChild("HumanoidRootPart")
end

localPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    updateCharacter()
end)

local function isEnemy(p)
    return p ~= localPlayer and p.TeamColor == BrickColor.new("Bright blue") and p.Character
end

local function getNearbyEnemies()
    local list = {}
    for _, p in pairs(services.Players:GetPlayers()) do
        if isEnemy(p) then
            local enemyRoot = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
            if enemyRoot then
                local dist = (hrp.Position - enemyRoot.Position).Magnitude
                if dist < searchRadius then
                    table.insert(list, {rootPart = enemyRoot, distance = dist})
                end
            end
        end
    end
    return list
end

local function repelFromEnemy(enemy)
    local dir = (hrp.Position - enemy.rootPart.Position).Unit
    local targetPos = hrp.Position + dir * (safeDistance - enemy.distance)

    if tweenCache[hrp] then tweenCache[hrp]:Cancel() end

    tweenCache[hrp] = services.TweenService:Create(
        hrp,
        TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
        {CFrame = CFrame.new(targetPos)}
    )
    tweenCache[hrp]:Play()
end

services.RunService.RenderStepped:Connect(function()
    if not repelActive or not hrp then return end
    local nearby = getNearbyEnemies()
    if #nearby > 0 then
        table.sort(nearby, function(a, b) return a.distance < b.distance end)
        repelFromEnemy(nearby[1])
    end
end)

services.Players.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function()
        if isEnemy(p) then task.wait(0.1) end
    end)
end)



	local ProximityPromptTimeBet = 2.3
	local autoArrest = false


    Tab6:AddButton({
        Name = "Load Infinite Yield",
        Callback = function()
            loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source', true))()
        end
    })
    

--------------------------------------------------------------------
--  ACB (Anti‑Cheat Bypasser) – isolated, crash‑proof, no conflicts
--------------------------------------------------------------------
local ACB = {}               -- private namespace – nothing leaks

-- executor capability test
do
    local ok = pcall(function()
        ACB.getrawmetatable   = getrawmetatable
        ACB.setreadonly       = setreadonly
        ACB.newcclosure       = newcclosure
        ACB.getnamecallmethod = getnamecallmethod
    end)
    ACB.executorSupported = ok
            and typeof(ACB.getrawmetatable)   == "function"
            and typeof(ACB.setreadonly)       == "function"
            and typeof(ACB.newcclosure)       == "function"
            and typeof(ACB.getnamecallmethod) == "function"
end

--≡ constants
ACB.BLOCKED = {
    ["e29cfe0e-3520-40a1-8c0d-662158c150bb"] = true,
    ["e37fa0bd-4679-4293-a5e0-7a50f3b50d47"] = true,
    ["2328c9a3-b855-4e6b-abb5-14491dd3cd24"] = true,
}

--≡ internal state
ACB.enabled    = false
ACB.hook       = nil
ACB.oldCall    = nil
ACB.mt         = nil

--≡ safe hook install
function ACB.enable()
    if ACB.hook then return end
    local ok, err = pcall(function()
        ACB.mt       = ACB.mt or ACB.getrawmetatable(game)
        ACB.oldCall  = ACB.oldCall or ACB.mt.__namecall
        ACB.setreadonly(ACB.mt, false)

        ACB.hook = ACB.newcclosure(function(self, ...)
            local m = ACB.getnamecallmethod()
            if (m == "FireServer" or m == "InvokeServer")
                and typeof(self) == "Instance"
                and (self:IsA("RemoteEvent") or self:IsA("RemoteFunction"))
                and ACB.BLOCKED[self.Name] then
                warn(("[ACB] blocked %s ➜ %s"):format(m, self:GetFullName()))
                return nil
            end
            return ACB.oldCall(self, ...)
        end)

        ACB.mt.__namecall = ACB.hook
        ACB.setreadonly(ACB.mt, true)
    end)
    if not ok then
        warn("[ACB] hook failed:", err)
        ACB.hook = nil
    else
        print("[ACB] active – listed remotes blocked")
    end
end

--≡ safe hook removal
function ACB.disable()
    if not ACB.hook then return end
    pcall(function()
        ACB.setreadonly(ACB.mt, false)
        ACB.mt.__namecall = ACB.oldCall
        ACB.setreadonly(ACB.mt, true)
    end)
    ACB.hook = nil
end

--------------------------------------------------------------------
--  UI wiring (no globals; uses local ref to Tab6 only)
--------------------------------------------------------------------
do
    local toggleRef         -- holds the returned toggle object, if your UI lib supports SetState
    toggleRef = Tab6:AddToggle({
        Name     = "AntiCheat bypasser",
        Default  = false,
        Callback = function(val)
            if not ACB.executorSupported then
                if toggleRef and toggleRef.SetState then toggleRef:SetState(false) end
                return
            end
            ACB.enabled = val
            if val then ACB.enable() else ACB.disable() end
        end
    })

    if ACB.executorSupported then
        Tab6:AddParagraph(
            "AntiCheat bypasser",
            "Enable to block the 'Infinite Yield' ban checks. Turn off again to use seats, cars, etc. normally."
        )
    else
        Tab6:AddParagraph(
            "AntiCheat bypasser not supported",
            "Your executor lacks one or more required functions. The toggle is therefore disabled."
        )
    end
end



	local playerStuffTab = Window:MakeTab({
		Name = "│Crim-Cop Mod's",
		Icon = "rbxassetid://4483345998",
		PremiumOnly = false
	})

	
	
local UserInputService = game:GetService("UserInputService")
local VirtualUser = game:GetService("VirtualUser")
local LocalPlayer = Players.LocalPlayer
	
	

	local aAToggle = playerStuffTab:AddToggle({
		Name = "│Police│ AutoArrest (not instantly)",
		Default = false,
		Callback = function(Value)
			autoArrest = Value
			local toggle
			if autoArrest == true then
				toggle = "On"
			else
				toggle = "Off"
			end
			OrionLib:MakeNotification({
				Name = "Auto-Arrest Enabled",
				Content = "Now: "..toggle,
				Image = "rbxassetid://4483345998",
				Time = 2.5
			})
		end
	})
	
	playerStuffTab:AddBind({
		Name = "│Police│ Auto-Arrest Keybind",
		Default = Enum.KeyCode.Y,
		Hold = false,
		Callback = function()
			autoArrest = not autoArrest			
			aAToggle:Set(autoArrest)
		end   
	})


	
	local function updateWanted(eventData)
		for playerName, _ in pairs(wantedPlayers) do
			if not eventData[playerName] then
				wantedPlayers[playerName] = nil
			end
		end
	
		for i, v in pairs(game.Players:GetPlayers()) do
			if eventData[v.Name] and not wantedPlayers[v.Name] then
				wantedPlayers[v.Name] = true
			end
		end
	end
		
	local function isModelInRenderDistance(model)
		local player = Players.LocalPlayer
		if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local playerPosition = player.Character.HumanoidRootPart.Position
			local modelPosition = model:GetModelCFrame().Position
			local distance = (modelPosition - playerPosition).Magnitude
			return distance <= MAXCARDISTANCE
		end
		return false
	end

	

	
	wantedRemoteEvent.OnClientEvent:Connect(function(eventData)
		if typeof(eventData) == "table" then
			updateWanted(eventData)
		end
	end)
	
	

	





	local cooldown = false
	game:GetService("RunService").RenderStepped:Connect(function() 
		if cooldown == false then
			cooldown = true
			if autoArrest then
				for _, player in ipairs(game.Players:GetPlayers()) do
					if player.Character then
						local humanoid = player.Character:FindFirstChild("Humanoid")
						local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
						
						if humanoid and humanoid.Health > 30 and rootPart then
							local distance = (rootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
							local playerName = player.Name 
							local isWanted = wantedPlayers[playerName] ~= nil
							if distance < 12 then
								if isWanted then
									local args = {
										[1] = "Handcuffs"
									}
									EquipRemoteEvent:FireServer(unpack(args))
									local args = {rootPart, "e52", true}
									ArrestRemoteEvent:FireServer(unpack(args))
									task.wait(ProximityPromptTimeBet)
									local args = {rootPart, "e52", false}
									ArrestRemoteEvent:FireServer(unpack(args))
								end
							end
						end
					end
				end
			end
			task.wait(0.25)
			cooldown = false
		end
	end)


playerStuffTab:AddLabel("----------------------------------")

-- Fixed Auto Taser System - Always Hits
local TaserEnabled = false
local TaserCooldown = false
local taserWantedPlayers = {}

-- Update wanted players for taser
wantedRemoteEvent.OnClientEvent:Connect(function(eventData)
    if typeof(eventData) == "table" then
        table.clear(taserWantedPlayers)
        for name in pairs(eventData) do
            if name ~= LocalPlayer.Name then
                taserWantedPlayers[name] = true
            end
        end
    end
end)

-- Fixed target validation
local function isValidTaserTarget(player)
    if player == LocalPlayer then return false end
    if not player.Character then return false end
    
    local humanoid = player.Character:FindFirstChild("Humanoid")
    local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
    local head = player.Character:FindFirstChild("Head")
    
    if not humanoid or not rootPart or not head then return false end
    
    -- Check if player is knocked
    if humanoid.Health <= (humanoid.MaxHealth * 0.2) then return false end
    
    -- Check distance (30 studs max for better accuracy)
    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
    if distance > 30 then return false end
    
    -- Check if player is wanted
    if not taserWantedPlayers[player.Name] then return false end
    
    return true
end

-- Get closest wanted target
local function getClosestWantedTarget()
    local closest = nil
    local shortestDist = 30
    
    for _, player in ipairs(game.Players:GetPlayers()) do
        if isValidTaserTarget(player) then
            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < shortestDist then
                shortestDist = distance
                closest = player
            end
        end
    end
    
    return closest
end

-- Fixed taser equip
local function equipTaser()
    if not LocalPlayer.Character then return false end
    
    if LocalPlayer.Character:FindFirstChild("Taser") then
        return true
    end
    
    local args = {"Taser"}
    EquipRemoteEvent:FireServer(unpack(args))
    task.wait(0.5)
    return LocalPlayer.Character:FindFirstChild("Taser") ~= nil
end

-- Fixed taser firing - guaranteed hits
local function fireTaser()
    if not TaserEnabled or TaserCooldown then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    
    -- Equip taser if needed
    if not LocalPlayer.Character:FindFirstChild("Taser") then
        if not equipTaser() then return end
    end
    
    local target = getClosestWantedTarget()
    if not target then return end
    
    -- Fire taser with correct remote event
    local taser = LocalPlayer.Character:FindFirstChild("Taser")
    if taser then
        -- Try multiple remote events to ensure it works
        pcall(function()
        TaserShootRemote:FireServer(
                taser,
                target.Character.HumanoidRootPart.Position,
                (target.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Unit
            )
        end)
        
        -- Also try the regular shoot remote as backup
        pcall(function()
            ShootRemoteEvent:FireServer(
                taser,
                target.Character.HumanoidRootPart.Position,
                (target.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Unit
            )
        end)
        
        -- Short cooldown
        TaserCooldown = true
        task.wait(1)
        TaserCooldown = false
    end
end

-- Auto taser toggle
local autoTaserToggle = playerStuffTab:AddToggle({
    Name = "│Police│ Auto-Taser (Always Hits)",
    Default = false,
    Callback = function(Value)
        TaserEnabled = Value
        if Value then
            OrionLib:MakeNotification({
                Name = "Auto Taser",
                Content = "Auto Taser Enabled - Will Always Hit!",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "Auto Taser",
                Content = "Auto Taser Disabled",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        end
    end
})

-- Auto taser keybind
playerStuffTab:AddBind({
    Name = "│Police│ Auto-Taser Keybind",
    Default = Enum.KeyCode.T,
    Hold = false,
    Callback = function()
        TaserEnabled = not TaserEnabled
        autoTaserToggle:Set(TaserEnabled)
    end
})

-- Run taser system with better timing
game:GetService("RunService").Heartbeat:Connect(function()
    if TaserEnabled then
        fireTaser()
    end
end)

playerStuffTab:AddParagraph("Fixed Auto Taser", "Turn on and it will always hit wanted players within 50 studs")

OrionLib:Init()



-- Gun mod update loop
RunService.Heartbeat:Connect(function()
    local weaponFolder = getPlayerWeaponFolder()
    if not weaponFolder then return end
    for _, weaponName in ipairs(WeaponNames) do
        local weapon = weaponFolder:FindFirstChild(weaponName)
        if weapon then
            if NoRecoil then
                pcall(function()
                    weapon:SetAttribute("Recoil", 0)
                    weapon:SetAttribute("RecoilAmount", 0)
                    weapon:SetAttribute("RecoilRecovery", 0)
                end)
            end
            if FastBullet then
                pcall(function()
                    weapon:SetAttribute("ShootDelay", 0)
                    weapon:SetAttribute("FireRate", 999)
                    weapon:SetAttribute("RateOfFire", 999)
                end)
            end
            if NoInstability then
                pcall(function()
                    weapon:SetAttribute("Instability", 0)
                end)
            end
            if NoSpread then
                pcall(function()
                    weapon:SetAttribute("Spread", 0)
                    weapon:SetAttribute("BulletSpread", 0)
                end)
            end
        end
    end
    
    -- Small Crosshair
    if SmallCrosshair then
        pcall(function()
            local cross = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Crosshair")
            if cross then
                cross.Size = UDim2.new(0, 4, 0, 4)
            end
        end)
    else
        pcall(function()
            local cross = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Crosshair")
            if cross then
                cross.Size = UDim2.new(0, 40, 0, 40)
            end
        end)
    end
end)
